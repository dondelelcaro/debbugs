#!/usr/bin/perl
# $Id: processall.in,v 1.12 2005/10/06 03:40:32 ajt Exp $
#
# Usage: processall
#
# Uses up: incoming/I<code><bugnum>.nn
# Temps:   incoming/[GP].nn
# Creates: incoming/E.nn
# Stop:    stop

$config_path = '/etc/debbugs';
$lib_path = '/usr/lib/debbugs';

require "$config_path/config";
require "$lib_path/errorlib";
$ENV{'PATH'} = $lib_path.':'.$ENV{'PATH'};

use File::Path;

chdir( $gSpoolDir ) || die "chdir spool: $!\n";
push( @INC, $lib_path );

#open(DEBUG,">&4");

umask(002);

$|=1;
undef %fudged;

&filelock('incoming-cleaner');
for (;;) {
    if (-f 'stop') {
        print(STDERR "stop file created\n") || die $!;
        last;
    }
    if (!@ids) {
        opendir(DIR,"incoming") || die $!;
        while ( defined( $_= readdir(DIR) )) { push(@ids,$_) if s/^I//; }
        last unless @ids;
        @ids= sort(@ids);
    }
    stat("$gMaintainerFile") || die "stat $gMaintainerFile: $!\n";
    $nf= @ids;
    $id= shift(@ids);
    unless (rename("incoming/I$id","incoming/G$id")) {
        if ($fudged{$id}) {
            die "$id already fudged once! $!\n";
        }
        $fudged{$id}= 1;
        next;
    }
    if ($id =~ m/^[RC]/) {
        print(STDOUT "[$nf] $id service ...") || die $!;
        defined($c=fork) || die $!;
        if (!$c) { exec("$lib_path/service",$id); die $!; }
    } elsif ($id =~ m/^[BMQFDUL]/) {
        print(STDOUT "[$nf] $id process ...") || die $!;
        defined($c=fork) || die $!;
        if (!$c) { exec("$lib_path/process",$id); die $!; }
    } else {
        die "bad name $id";
    }
    $cc=waitpid($c,0); $cc == $c || die "$cc $c $!";
    $status=$?;
    if ($status) {
        print(STDERR "$id: process failed ($status $!) - now in [PG]$id\n") || die $!;
    }
    print(STDOUT " done\n") || die $!;
    rmtree("$gSpoolDir/mime.tmp",0,1);
    $ndone++;
}
&unfilelock;

exit(0);
