#! /usr/bin/perl
# debbugs-loadsql is part of debbugs, and is released
# under the terms of the GPL version 2, or any later version, at your
# option. See the file README and COPYING for more information.
# Copyright 2012 by Don Armstrong <don@donarmstrong.com>.


use warnings;
use strict;

use Getopt::Long qw(:config no_ignore_case);
use Pod::Usage;

=head1 NAME

debbugs-loadsql -- load debbugs sql database

=head1 SYNOPSIS

debbugs-loadsql [options]

 Options:
  --quick, -q only load changed bugs
  --service, -s service name
  --sysconfdir, -c postgresql service config dir
  --spool-dir debbugs spool directory
  --debug, -d debugging level (Default 0)
  --help, -h display this help
  --man, -m display manual

=head1 OPTIONS

=over

=item B<--quick, -q>

Only load changed bugs

=item B<--service,-s>

Postgreql service to use; defaults to debbugs

=item B<--sysconfdir,-c>

System configuration directory to use; if not set, defaults to the
postgresql default. [Operates by setting PGSYSCONFDIR]

=item B<--spool-dir>

Debbugs spool directory; defaults to the value configured in the
debbugs configuration file.

=item B<--debug, -d

Debug verbosity.

=item B<--help, -h>

Display brief useage information.

=item B<--man, -m>

Display this manual.

=back


=cut


use vars qw($DEBUG);

use Debbugs::Common qw(checkpid lockpid get_hashname getparsedaddrs getbugcomponent make_list);
use Debbugs::Config qw(:config);
use Debbugs::Status qw(read_bug split_status_fields);
use Debbugs::Log;
use Debbugs::DB;
use Debbugs::DB::Load qw(load_bug handle_load_bug_queue);
use DateTime;
use File::stat;


my %options = (debug           => 0,
	       help            => 0,
	       man             => 0,
	       verbose         => 0,
	       quiet           => 0,
	       quick           => 0,
	       service         => 'debbugs',
               progress        => 0,
	      );


GetOptions(\%options,
	   'quick|q',
	   'service|s',
	   'sysconfdir|c',
           'progress!',
	   'spool_dir|spool-dir=s',
	   'debug|d+','help|h|?','man|m');

pod2usage() if $options{help};
pod2usage({verbose=>2}) if $options{man};

$DEBUG = $options{debug};

my @USAGE_ERRORS;
$options{verbose} = $options{verbose} - $options{quiet};

if ($options{progress}) {
    eval "use Term::ProgressBar";
    push @USAGE_ERRORS, "You asked for a progress bar, but Term::ProgressBar isn't installed" if $@;
}


pod2usage(join("\n",@USAGE_ERRORS)) if @USAGE_ERRORS;

if (exists $options{sysconfdir}) {
    if (not defined $options{sysconfdir} or not length $options{sysconfdir}) {
	delete $ENV{PGSYSCONFDIR};
    } else {
	$ENV{PGSYSCONFDIR} = $options{sysconfdir};
    }
}

if (exists $options{spool_dir} and defined $options{spool_dir}) {
    $config{spool_dir} = $options{spool_dir};
}
chdir($config{spool_dir}) or die "chdir $config{spool_dir} failed: $!";

my $verbose = $options{debug};

my $initialdir = "db-h";

if (defined $ARGV[0] and $ARGV[0] eq "archive") {
    $initialdir = "archive";
}

if (not lockpid($config{spool_dir}.'/lock/debbugs-loadsql')) {
     if ($options{quick}) {
	  # If this is a quick run, just exit
	  print STDERR "Another debbugs-loadsql is running; stopping\n" if $verbose;
	  exit 0;
     }
     print STDERR "Another debbugs-loadsql is running; stopping\n";
     exit 1;
}


# connect to the database; figure out how to handle errors properly
# here.
my $schema = Debbugs::DB->connect('dbi:Pg:service='.$options{service}) or
    die "Unable to connect to database: ";

my $time = 0;
my $start_time = time;


my @dirs = (@ARGV?@ARGV : $initialdir);
my $cnt = 0;
my %tags;
my %severities;
my %queue;
my $tot_dirs = @ARGV ? @ARGV : 0;
my $done_dirs = 0;
my $avg_subfiles = 0;
my $completed_files = 0;
my $p;
if ($options{progress}) {
    $p = eval "Term::ProgressBar->new({count => 1,ETA=>q(linear)})";
    warn "Unable to initialize progress bar: $@" if not $p;
}
while (my $dir = shift @dirs) {
    printf "Doing dir %s ...\n", $dir if $verbose;

    opendir(DIR, "$dir/.") or die "opendir $dir: $!";
    my @subdirs = readdir(DIR);
    closedir(DIR);

    my @list = map { m/^(\d+)\.summary$/?($1):() } @subdirs;
    $tot_dirs -= @dirs;
    push @dirs, map { m/^(\d+)$/ && -d "$dir/$1"?("$dir/$1"):() } @subdirs;
    $tot_dirs += @dirs;
    if ($avg_subfiles == 0) {
        $avg_subfiles = @list;
    }

    $p->target($avg_subfiles*($tot_dirs-$done_dirs)+$completed_files+@list) if $p;
    $avg_subfiles = ($avg_subfiles * $done_dirs + @list) / ($done_dirs+1);
    $done_dirs += 1;

    for my $bug (@list) {
        $completed_files++;
        $p->update($completed_files) if $p;
	print "Up to $cnt bugs...\n" if (++$cnt % 100 == 0 && $verbose);
	my $stat = stat(getbugcomponent($bug,'summary',$initialdir));
	if (not defined $stat) {
	    print STDERR "Unable to stat $bug $!\n";
	    next;
	}
	next if $stat->mtime < $time;
	my $data = read_bug(bug => $bug,
			    location => $initialdir);
        eval {
            load_bug(db => $schema,
                     data => split_status_fields($data),
                     tags => \%tags,
                     severities => \%severities,
                     queue => \%queue);
        };
        if ($@) {
            use Data::Dumper;
            print STDERR Dumper($data) if $DEBUG;
            die "failure while trying to load bug $bug\n$@";
        }
    }
}
$p->remove();
handle_load_bug_queue(db => $schema,
                      queue => \%queue);



__END__
